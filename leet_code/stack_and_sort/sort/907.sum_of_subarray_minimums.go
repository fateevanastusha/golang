package main

import (
	"fmt"
)

/*
3 1 2 4
*/
//time - O(n), mem - O(n)
func sumSubarrayMins(arr []int) int {
	/*
		тут нужно сначала найти расстояние до меньшего числа слева, а затем до меньшего числа справа для каждого числа.
		это делаем так же как в задаче на поиск через сколько дней будет бОльшая температура.

		для [3 1 2 4] получится:
		left = [1 2 1 1]
		right = [1 3 2 1]

		для 3:
		слева - нет, поэтому расстояние до индекса -1
		справа - 1, расстояние 1

		для 1:
		слева - нет
		справа - нет

		для 2:
		слева - 1
		справа - нет

		для 4:
		слева - 2
		справа - нет


		зачем?
		чтобы найти сумму всех минимумах во всех подмассивах мы для каждого числа ищем в каком количестве подмассивов он является
		минимумом. чтобы это сделать, надо найти расстояние до ближайшего числа, которое меньше текущего, слева и справа. это будут
		как "возможные позиции" для границы подмассива так, чтобы число было в этих границах минимумом.
		например, для 2 все подмассивы, где он минимум -
		[2] [2 4] (2 штуки). значит его надо прибавить два раза к ответу.
		для 3:
		[3] (1 штука)
		для 4:
		[4] (1 штука)
		для 1:
		[3 1 2 4] [3 1 2] [1 2 4] [3 1] [1 2] [1] (6 штук)

		количество подмассивов где число минимум - это расстояние до левого меньшего числа умножить на расстояние до правого меньшего
		числа. именно для этого мы искали расстояния. так и складываем ответ.
	*/
	stack := []int{}
	right := make([]int, len(arr))
	left := make([]int, len(arr))
	mod := 1000000007
	var res int

	//найти для каждого числа расстояние до МЕНЬШЕГО справа(как в поиске температуры)
	for i, n := range arr {
		for len(stack) > 0 && n <= arr[stack[len(stack)-1]] {
			last := stack[len(stack)-1]
			stack = stack[0 : len(stack)-1]
			right[last] = i - last
		}

		stack = append(stack, i)
	}
	//допиливаем стэк
	for len(stack) > 0 {
		last := stack[len(stack)-1]
		stack = stack[0 : len(stack)-1]
		right[last] = len(arr) - last
	}

	//найти для каждого числа расстояние до МЕНЬШЕГО слева (как в поиске температуры)
	for i := len(arr) - 1; i >= 0; i-- {
		n := arr[i]
		for len(stack) > 0 && n < arr[stack[len(stack)-1]] {
			last := stack[len(stack)-1]
			stack = stack[0 : len(stack)-1]
			left[last] = last - i
		}
		stack = append(stack, i)
	}
	//допиливаем стэк
	for len(stack) > 0 {
		last := stack[len(stack)-1]
		stack = stack[0 : len(stack)-1]
		left[last] = last + 1
	}

	//получаем ответ
	for i, n := range arr {
		//%mod нужно чтобы ответ вместился в инт
		res = (res + (n * left[i] * right[i])) % mod
	}

	return res
}

func main() {
	n := []int{3, 1, 2, 4}
	fmt.Println(sumSubarrayMins(n))
}
