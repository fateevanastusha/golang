СПОСОБЫ ХРАНЕНИЯ ГРАФОВ

у нас есть граф: 
1 → 2
2 → 4
1 → 8

- матрица смежности
            КУДА
          1 2 3 4 8
ОТКУДА  1 F T F F T
        2 F F F T F

- список ребер
[[1,2], [2,4], [1, 8]]

- список смежности
либо мапой, либо списком (где индекс - это откуда, а значение - куда)
МАПОЙ:
1: [2,8]
2: [4]
СПИСКОМ: 
[ [ ], [2,8], [4] ]
   0     1     2



------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------



СВЯЗНАЯ КОМПОНЕНТА ГРАФА
это кусок графа где границы соеденены между собой
3 → 1           4
    ↓           ↓
    2           5
- вот тут две связные компоненты графа - (3,1,2) и (4,5)



------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------



ЧТО ТАКОЕ ЦИКЛ В ГРАФЕ. КАК МОЖНО ПРОВЕРИТЬ, ЧТО В ГРАФЕ ЕСТЬ ЦИКЛ?
- это когда граф зациклен. Проверить можно через DFS через алгоритм покраски графа (белый серый черный), 
если мы приходим в серую вершину, значит есть цикл.
3 → 1
↑   ↓
2 ← 
вот он:
1 → 2 → 3 → 1

кодом: 

// time - O(n), mem - O(n)
func canFinish(numCourses int, prerequisites [][]int) bool {
	/*
		1 - white
		2 - gray
		3 - black
	*/
	matrix := [][]int{}
	for i := 0; i < numCourses; i++ {
		matrix = append(matrix, []int{})
	}
	for _, v := range prerequisites {
		a, b := v[0], v[1]
		matrix[a] = append(matrix[a], b)

	}

	colors := []int{}
	for i := 0; i < numCourses; i++ {
		colors = append(colors, 0)
	}

	var hasCycle func(n int) bool
	hasCycle = func(n int) bool {
        //если вернулись в серую - есть цикл
		if colors[n] == 1 {
			return true
		}
        //попали в черную - цикла нет
		if colors[n] == 2 {
			return false
		}
        //красим вершину в серую
		colors[n] = 1
        //обходим все ее зависимости
		for _, next := range matrix[n] {
			if hasCycle(next) {
				return true
			}
		}
        //после обхода всех зависимостей понимаем, что не пришли в нее обратно - красим в черную
		colors[n] = 2

		return false
	}

	for n := 0; n < numCourses; n++ {
		if hasCycle(n) {
			return false
		}
	}

	return true
}
на вход поступает список ребер: [][]int{{1, 2}, {2, 3}, {4, 3}}
1 → 2
2 → 3
4 → 3


------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------



ТОПОЛОГИЧЕСКАЯ СОРТИРОВКА
показать в каком порядке элементы графа должны иметь зависимости. Можно сделать только если граф не зациклен.
1 → 2 → 4 → 6
↓   ↓       ↑
3 → 5 →─────┘
↓
7
тогда топологическая сортировка будет: 1 2 3 5 7 4 6 (может быть и другой порядок, главное чтобы зависимости соблюдались)

кодом (тут мы еще проверяем что нет цикла): 
// time - O(n), mem - O(n)
func findOrder(numCourses int, prerequisites [][]int) []int {
	/*
		топологическая сортировка
	*/
	matrix := make([][]int, numCourses)
	colors := make([]int, numCourses)
	for _, n := range prerequisites {
		a, b := n[0], n[1]
		matrix[a] = append(matrix[a], b)
	}

	res := []int{}

	var dfs func(n int) bool
	dfs = func(n int) bool {
		if colors[n] == 1 {
			return true
		}
		if colors[n] == 2 {
			return false
		}
		colors[n] = 1
		for _, c := range matrix[n] {
			//check if we have cycle
			if dfs(c) {
				return true
			}
		}
		colors[n] = 2
		res = append(res, n)
		return false
	}

	for c := 0; c < numCourses; c++ {
		if dfs(c) {
			return []int{}
		}
	}
	return res
}

------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------



КОГДА НУЖЕН DFS, А КОГДА BFS? 
примеры: 
DFS: 
- топологическая сортировка
- поиск цикла
BFS: 
- поиск пути





