package main

import "fmt"

func getValue(s []rune, i int) rune {
	if i >= len(s) {
		return '!'
	}
	return s[i]
}

/*
	дана строка. если мы можем сделать их равными ОДНИМ действием - то true, иначе - false.
	если они изначально равны - это false.
*/
// time - O(max(n,m)) - n и m - длины строк, mem - O(1)
func solve(s, t string) bool {
	sR, tR := []rune(s), []rune(t)
	steps, p1, p2 := 0, 0, 0
	for p1 < len(sR) || p2 < len(tR) {
		//если у одного указатель уже вышел за пределы - берем рандомный символ, которого точно нет
		v1, v2 := getValue(sR, p1), getValue(tR, p2)
		n, m := len(sR)-p1, len(tR)-p2
		//не равны
		if v1 != v2 {
			//смотрим у кого больше букв впереди оказалось
			//если p1 длиннее - то двигаем p1 (удалили лишний символ)
			/*
				  	   ↓
				p1 = a b c
				p2 = a c
				  	   ↑

				  	     ↓
				p1 = a b c
				p2 = a c
				  	   ↑

				(как будто удалили b)
			*/
			if n > m {
				p1++
			}
			//если p2 длиннее - то двигаем p2 (удалили лишний символ)
			/*
				  	   ↓
				p1 = a c
				p2 = a b c
				  	   ↑

				  	   ↓
				p1 = a c
				p2 = a b c
				  	     ↑

				(как будто удалили b)
			*/
			if m > n {
				p2++
			}
			//если одинаково - то двигаем оба (заменили букву у первого или второго)

			/*
				  	   ↓
				p1 = a c c
				p2 = a b c
				  	   ↑

				  	     ↓
				p1 = a c c
				p2 = a b c
				  	     ↑

				(как будто c заменили на b или b на с)
			*/
			if m == n {
				p1++
				p2++
			}
			//добавляем счетчик, что сделали какое-то действие
			steps++
		} else {
			//оба равны, двигаем оба указателя
			p1++
			p2++
		}
	}
	//действие должно быть только одно!
	return steps == 1
}

func main() {
	s := "aaaaaaa"
	t := "a"
	fmt.Println(solve(s, t))
}
