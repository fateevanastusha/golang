Какие бывают массивы: 
1) возрастающий [1,3,4,5,7,8,11] - нет дубликатов, только растет
2) монотонно возрастающий [1,1,1,5,6,7,8,8,9] - могут быть дубликаты
3) не убывающий [] - [1,1,1,1,1,1,1,1] - нет убывания

можно применять бинарный поиск если мы можем разделить массив на две части - good и bad.

[-1,0,3,5,6,9,10,12], target = 9
|.............|....|
    good       bad
в good содержится ответ скраю справа, а в bad - нет


func (a int) bool { - должна давать для good = true, а для bad = false
    a <= target
}

Оперируем ПОСЛЕДНИМ good, ПЕРВЫМ bad


func good(v, t int) bool {
	return v <= t              - ПО СУТИ МЕНЯЕТСЯ ТОЛЬКО ЭТА ФУНКЦИЯ ВО ВСЕХ ЗАДАЧАХ
}

// time - O(logn), mem - O(1)
func search(nums []int, t int) int {
	l, r := 0, len(nums)
	for r-l > 1 {
		m := (l + r) / 2
		if good(nums[m], t) {
			l = m
		} else {
			r = m
		}
	}
	if nums[l] == t {
		return l
	}
	return -1
}

target = 9

mid=0+6/2 = 3
[-1, 0, 3, 5, 9, 12]
 ↑         m        ↑

mid=6+3/2=4
[-1, 0, 3, 5, 9, 12]
           ↑  m     ↑

mid=4+6/2=5
[-1, 0, 3, 5, 9, 12]
              ↑  m  ↑

stop
[-1, 0, 3, 5, 9, 12]
              ↑   ↑


ВАЖНО!!!!

ОТВЕТ ВСЕГДА В УКАЗАТЕЛЕ БЕЗ СДВИГА! (left=0 ИЛИ right=len(n)-1)
УКАЗАТЕЛЬ СО СДВИГОМ (left=-1 ИЛИ right=len(n)) - ЭТО ТОТ УКАЗАТЕЛЬ, ГДЕ НЕ МОЖЕТ БЫТЬ ОТВЕТА!

ДЕЛИМ МАССИВ НА "ХОРОШУЮ" И "ПЛОХУЮ" ЧАСТИ, ДЛЯ ПЛОХОЙ - СДВИГ, В ХОРОШЕЙ - ОТВЕТ