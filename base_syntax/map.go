package main

import "fmt"

func main() {
	/*
		Отображения (или карты, или map) — это структура данных, представляющая собой неупорядоченную
		коллекцию пар "ключ-значение" (хэш-таблица).
		- каждый ключ в отображении уникален
		- связанное с ключом значение можно получить, обновить или удалить независимо от других элементов
		- представляет собой ссылку на хеш-таблицу
		- все ключи в одном отображении должны иметь одинаковый тип, как и все значения
	*/

	//1) записать
	/*
		пишется как map[K]V
		K — тип ключа
		V — тип значения
	*/

	// С использованием встроенной функции make:
	m1 := make(map[int]int)

	// Или с использованием литерала отображения (сразу определить ключи и значения):
	m2 := map[int]int{
		12: 2, // ключ 12, значение 2
		1:  5, // ключ 1, значение 5
	}

	fmt.Println(m1) // вывод: map[]
	fmt.Println(m2) // вывод: map[1:5 12:2]

	/*
		ТАК НЕЛЬЗЯ!
		var m map[int]int
		m[12] = 3
		fmt.Println(m)

		// Вывод (сработает паника):
		// panic: assignment to entry in nil map

		Если мы объявляем переменную с использованием var и не присваиваем ей начальное значение, Go
		присваивает переменной нулевое значение. Для отображения это будет значение nil (для числа - 0 и тд),
		а попытка добавить элемент в nil отображение приведет к ошибке assignment to entry in nil map и панике.

		Такой подход можно использовать если:

		var m map[int]int
		m = someFunc() // someFunc возвращает отображение
		fmt.Println(m)
		// Альтернативный вариант
		var m = map[int]int{} // Инициализация пустого отображения
		m = someFunc()        // someFunc возвращает отображение
		fmt.Println(m)
	*/

	//2) map ведет себя как указатель
	/*
		func main() {
			mm := map[string]int{
				"first":  1,
				"second": 2,
				"third":  3}
			fmt.Println(mm)
			changeMap(mm)
			fmt.Println(mm)
		}

		func changeMap(mp map[string]int) {
			mp["first"] = 10
		}
		//Указатели не использовали, и функция ничего не возвращает. Тем не менее, мапа меняется, потому что
		//это ссылка на таблицу.
		//Вывод:
		//map[first:1 second:2 third:3] - до
		//map[first:10 second:2 third:3] - после
	*/

	fmt.Println("-----------------------------------------------------------------------")

	m := map[int]int{
		12: 2,
		1:  5,
		56: 3,
		77: 22,
	}

	//3) обращение к элементам
	fmt.Println(m[12])     // 2
	fmt.Println(m[100000]) // 0 (так как устанавливается нулевое значение для int)

	//как отличить нулевое значение от присвоенного?

	example := map[string]int{
		"Alina":  0,
		"Nastya": 100,
	}

	checkGradeBefore := func(name string) {
		if example[name] < 60 {
			fmt.Println(name, "is falling")
		} else {
			fmt.Println("ok")
		}
	}

	checkGradeBefore("Alina") //falling - это правильно
	checkGradeBefore("Mark")  //falling - это неправильно, так как в карте вообще нет такого значения
	/*
		так как нулевое значение у Mark = 0 (тип int), то оно ошибочно считывается. Определить значение
		или такого ключа нет можно через встроенный механизм:
	*/

	checkGradeAfter := func(name string) {
		value, ok := example[name]
		if ok == true && value < 60 {
			fmt.Println(name, "is falling")
		} else {
			fmt.Println(name, "is ok")
		}
	}

	checkGradeAfter("Alina") //falling - это правильно
	checkGradeAfter("Mark")  //ok - это правильно

	fmt.Println("-----------------------------------------------------------------------")

	//4) удаление элемента
	delete(m, 12)       // Удаляем элемент с ключом 12
	delete(m, 10000000) // Удаляем несуществующий элемент - ошибки не будет
	fmt.Println(m)      // map[1:5, 56:3, 77:22]

	fmt.Println("-----------------------------------------------------------------------")

	//5) перебор всех пар "ключ-значение"
	//перебирает в случайном порядке, так как это неупорядоченная структура данных
	for key, value := range m {
		fmt.Println(key, value)
	}

	fmt.Println("-----------------------------------------------------------------------")

	//6) узнать количество пар

	fmt.Println(len(m)) // 3

}
